---
title: "DSP Analysis QC Report"
format:
  html:
    code-fold: true
editor: visual
#css: "qc_report_style.css"

params:
  dsp.analysis.folder : "/Users/cauleyes/CPTR/DSP_Analysis/"
  data.folder: "/Users/cauleyes/CPTR/CPTR-10_Tosato/"
  results.folder: "/Users/cauleyes/CPTR/CPTR-10_Tosato/all_combined/QC/"
  run.folder: "4_3_25/"
---

## Load Libraries

```{r Load Libraries}
#| warning: false
#| message: false

# Load all relevant libraries

library(DSPWorkflow)
library(GeomxTools)
library(dplyr)
library(limma)
library(edgeR)
library(ggplot2)
library(ggrepel)
library(ggforce)
library(shadowtext)
library(stringr)
library(PCAtools)
library(readxl)
library(gridExtra)
library(grid)
library(knitr)
library(gt)
library(tidyr)
library(openxlsx)
library(ComplexUpset)
library(preprocessCore)
library(reshape2)
library(cowplot)

source(paste0(params$dsp.analysis.folder, "DSP_QC_functions.R"))
```

## Initialization

```{r Initialization}

# Input file parameters

pkc.file.name <- "Mm_R_NGS_WTA_v1.0.pkc"
pkc.file.path <- paste0(params$data.folder, pkc.file.name)

annotation.file.name <- "annotation_tosato_CPTR10.xlsx"
annotation.file.path <- paste0(params$data.folder, 
                               "all_combined/", 
                               annotation.file.name)

dcc.files <- list.files(file.path(paste0(params$data.folder, "dcc")),
  pattern = ".dcc$",
  full.names = TRUE,
  recursive = TRUE
)

alt.cluster.id <- c("DSP-1001660021202-A-C06.dcc", 
              "DSP-1001660011463-B-F11.dcc", 
              "DSP-1001660013737-F-G09.dcc", 
              "DSP-1001660011463-B-G01.dcc")

remove.dcc.file.paths <- unique(unlist(lapply(alt.cluster.id, 
                                  function(pattern) grep(pattern, 
                                                         dcc.files,
                                                         value = TRUE))))

dcc.files.subset <- setdiff(dcc.files, remove.dcc.file.paths)

# Annotation parameters
annotation.sheet.name <- "All ROIs"
sample.id.field.name <- "Sample_ID"
roi.field.name <- "ROI"
panel.field.name <- "panel"
class.field.name <- "class"
region.field.name <- "region"
segment.field.name <- "Segment"
area.field.name <- "area"
nuclei.field.name <- "nuclei"
exclude.sankey <- TRUE
segment.id.length <- 8

# Create the GeoMxSet Object

init.object <- initialize_object(dcc.files = dcc.files.subset,
                            pkc.files = pkc.file.path,
                            annotation.file = annotation.file.path,
                            annotation.sheet.name = annotation.sheet.name,
                            sample.id.field.name = sample.id.field.name,
                            roi.field.name = roi.field.name,
                            panel.field.name = panel.field.name, 
                            class.field.name = class.field.name, 
                            region.field.name = region.field.name, 
                            segment.field.name = segment.field.name,
                            area.field.name = area.field.name,
                            nuclei.field.name = nuclei.field.name, 
                            segment.id.length = segment.id.length)

```

## Object Summary

@fig-sankey shows a summary of AOIs per annotation

```{r Object Summary, fig.width=12, fig.height=8}
#| label: fig-sankey
#| fig-cap: "Sankey Plot"
#| warning: false

sankey.output <- plot_sankey(object = init.object, 
                      lane.1 = "slide", 
                      lane.2 = "class", 
                      lane.3 = "region", 
                      lane.4 = "segment", 
                      fill.lane = "class")

print(sankey.output$sankey.plot)
```

@fig-aoibarplot shows the total AOI counts per annotation

```{r AOI Count Bar Plot, fig.width=12, fig.height=8}
#| label: fig-aoibarplot
#| fig-cap: "AOI Count Bar Plot"
#| warning: false

print(sankey.output$AOI.bar.plot)

```

@fig-upsetr shows the size of annotation groups

```{r UpsetR Plot, fig.width=12, fig.height=8}
#| label: fig-upsetr
#| fig-cap: "UpSetR Plot"
#| warning: false

upsetr.plot <- upsetr_plot(object = init.object, 
                           annotation.groups = c("class", 
                                                 "region", 
                                                 "segment"))

print(upsetr.plot)


```

## QC and Filtering

```{r QC and Filtering}


qc.output <-  qcProc(object = init.object,
                        min.segment.reads = 1000, 
                        percent.trimmed = 80,    
                        percent.stitched = 80,   
                        percent.aligned = 80,    
                        percent.saturation = 50, 
                        min.negative.count = 1,   
                        max.ntc.count = 1000,     
                        min.nuclei = 3,         
                        min.area = 1000,
                        print.plots = FALSE)
    

```

Summary of QC for AOIs and Probes

```{r QC Summary}

qc.output$table

```

#### AOI QC

AOI distribution by parameter and annotation

```{r AOI Plots}

# Print AOI plots
qc.output$plot$trimmed
qc.output$plot$aligned
qc.output$plot$stitched
qc.output$plot$saturated


```

AOIs that have been flagged with the given QC parameters

```{r AOI Flags}

aoi.flag.table <- aoi_flag_table(aoi.flags = qc.output$segment.flags)

aoi.flag.table

```

### Probe QC

Probes that have been flagged as either local or global outliers.

probe.flag.output

```{r Probe Flag Tables}

probe.flag.output <- probe_flag_table(probe.flags = qc.output$probe.flags, 
                                      object = qc.output$object)

probe.flag.output$probe.flag.summary

probe.flag.output$probe.flags.table
```

### Filtering

```{r Filtering}

# Add LOQ and calculate detection of genes per AOI
loq.detection.output <- loq_detection(object = qc.output$object, 
              pkc.file.names = pkc.file.name)

```

#### Overall Gene Detection per AOI

@fig-GeneDetectionbByAOI shows detection rate per AOI, colored by region.

```{r Overall Gene Detection per AOI}
#| label: fig-GeneDetectionbByAOI
#| tbl-cap: "Overall Gene Detection per AOI"
#| warning: false

aoi.detection <- aoi_detection(object = loq.detection.output$object)

print(aoi.detection$detection.bar.plot)
```

AOIs in the low detection bin of 1-5%

```{r Low Detection AOI}
#| warning: false
#| message: false

aoi.detection$low.detection.table

```

Gene detection for all AOIs

```{r Gene Detection All AOIs}
#| warning: false
#| message: false

# Store the AOI detection for export in the QC summary
aoi.detection.summary <- pData(loq.detection.output$object) %>% 
  select(any_of(c("segmentID", "GeneDetectionRate", "DetectionThreshold")))

```

##### Filter out AOIs with low detection

```{r Filter by AOI}
#| warning: false
#| message: false

object <- loq.detection.output$object

# Filter the data using the cutoff for gene detection rate
aoi.gene.rate.cutoff <- 5

object.aoi.filtered <-
    object[, pData(object)$GeneDetectionRate >= aoi.gene.rate.cutoff]

# Create a table of AOIs that are filtered out
aoi.filtered.out <- pData(object[, pData(object)$GeneDetectionRate < aoi.gene.rate.cutoff])

aoi.filtered.out.table <- aoi.filtered.out %>% 
  select(segmentID, GeneDetectionRate) %>% 
  gt() %>% 
  tab_header(title = "AOIs Filtered Out", 
             subtitle = paste0(aoi.gene.rate.cutoff, "% Cutoff"), preheader = NULL)

aoi.filtered.out.table

```

#### Detection per Gene

```{r Detection per Gene}
#| warning: false
#| message: false

# Rerun LOQ to calculate new detection rate for individual genes:
loq.detection.output.aoi.filtered <- loq_detection(object = object.aoi.filtered, 
                                      pkc.file.names = pkc.file.name)

object.loq.detection <- loq.detection.output.aoi.filtered$object

```

@fig-DetectionPerGene shows the percent of all AOIs individual genes are detected within

```{r Gene Detection Plot}
#| label: fig-GeneDetection
#| fig-cap: "Gene Detection Percent of All AOIs"
#| warning: false

gene.detection <- gene_detection(object = object.loq.detection, 
                                 facet.column = "region", 
                                 loq.mat = loq.detection.output.aoi.filtered$loq.matrix)

print(gene.detection$total.plot)
```

@fig-FacetGeneDetection shows the gene detection as a percent of all AOIs per annotation group

```{r Facet Gene Detection Plot}
#| label: fig-FacetGeneDetection
#| fig-cap: "Gene Detection Percent of All AOIs per Annotation Group"
#| warning: false

print(gene.detection$facet.plot)

```

Gene detection rates for specified genes of interest

```{r Genes of Interest}
#| label: tbl-GenesOfInterest
#| tbl-cap: "Gene of Interest Detection Rate"
#| warning: false

# Gene of interest detection table
goi <- c("Cdh5", "Lyve1")

goi.df <- data.frame(Gene = goi,
                     Number = fData(object.loq.detection)[goi, "DetectedSegments"],
                     DetectionRate = fData(object.loq.detection)[goi, "DetectionRate"])

# Print the GOI table
goi.table <- goi.df %>% gt()

goi.table
```

@fig-DetectionPerGeneLoss shows the loss of percentage of all AOIs individual genes are detected within

```{r Gene Detection Rates Loss Plot}
#| label: fig-DetectionPerGeneLoss
#| fig-cap: "Gene Detection Loss"
#| warning: false

print(gene.detection$detect.loss.plot)

```

Summary of all gene detection rates

```{r Gene Detection Rate Summary}


# Gather a summary of the every gene's detection percentage in all AOIs
gene.detection.summary <- fData(object.loq.detection) %>% 
  mutate(gene = rownames(fData(object.loq.detection))) %>% 
  select(any_of(c("gene", "DetectionRate", "DetectionThreshold")))


```

##### Filter out genes with low detection

```{r Filter Genes}
#| warning: false
#| message: false

# Set the cutoff for gene detection (percentage)
gene.detection.cutoff <- 5

# Manually include the negative control probe, for downstream use
negative.probe.fData <- subset(fData(object.loq.detection), CodeClass == "Negative")
neg.probes <- unique(negative.probe.fData$TargetName)

# Subset for genes above the study gene detection rate cutoff
object.gene.filtered <- object.loq.detection[fData(object.loq.detection)$DetectionRate >= gene.detection.cutoff |
                   fData(object.loq.detection)$TargetName %in% neg.probes, ]

# Create a summary of genes that are filtered out
genes.filtered.out <- fData(object.loq.detection[fData(object.loq.detection)$DetectionRate < gene.detection.cutoff, ])

print(paste0(nrow(genes.filtered.out), " genes were filtered out of the GeoMxSet Object. For the full list, check the QC Output File."))
```

**Write QC Output File**

```{r Write QC output}

write.qc.file <- FALSE

if(write.qc.file == TRUE){
  
  # Start the QC output excel workbook
  qc.info.output <- createWorkbook()
  
  # Add the AOI flag info to the output file
  addWorksheet(qc.info.output, "AOI QC Flags")
  writeData(qc.info.output, sheet = "AOI QC Flags", qc.output$segment.flags)
  
  # Add the probe flag QC info to the output file
  addWorksheet(qc.info.output, "Probe QC Flags")
  writeData(qc.info.output, sheet = "Probe QC Flags", probe.flags.table)

  # Add the AOI detection QC info
  addWorksheet(qc.info.output, "AOI Detection Rate")
  writeData(qc.info.output, sheet = "AOI Detection Rate", segment.detection.summary)
  
  # Add the Gene detection QC info to the output file
  addWorksheet(qc.info.output, "Gene Detection Rate")
  writeData(qc.info.output, sheet = "Gene Detection Rate", gene.detection.summary)
  
  # Save the QC output file
  saveWorkbook(qc.info.output, paste0(params$results.folder, params$run.folder, "QC_info.xlsx"), overwrite = TRUE)
  
}


```

#### Q3 versus Negative Background

```{r Visualize Density of Q3 Scores versus Negative Background, warning=FALSE, message=FALSE}
#| label: fig-densityQ3vsBackground
#| fig-cap: "Density of Q3 Normalized Counts versus Background"
#| warning: false

plot.distribution <- plot_distribution(object = object.gene.filtered, 
                                       facet.annotation = "class")

print(plot.distribution$distr.plots)

print(plot.distribution$q3.neg.slope.plot)
```

#### Nuclei per ROI Plot

```{r Nuclei per Annotation}
#| warning: false
#| message: false

# Plot the number of nuclei per ROI for an annotation of interest
annotation <- pData(object.gene.filtered)

nuclei.plot <- nuclei_plot(annotation = annotation, 
                           color = "class", 
                           facet = "region", 
                           x.axis = "roi", 
                           order.by.ROI.num = TRUE, 
                           nuclei.field.name = "nuclei")

print(nuclei.plot)

```

### Normalization

```{r Normalization, warning=FALSE, message=FALSE}

q3.normalization.output <- geomxNorm(
                                  object = object.gene.filtered, 
                                  norm = "q3")
    
    
neg.normalization.output <- geomxNorm(
                                  object = object.gene.filtered, 
                                  norm = "neg")

# Quantile normalization
quantile.normalization.counts <- normalize.quantiles(object.gene.filtered@assayData$exprs)

dimnames(quantile.normalization.counts) = dimnames(object.gene.filtered@assayData$exprs)


# Gather the annotation
#annotation <- pData(q3.normalization.output$object)
#
## Fix the charcaters in the Animal ID column
#annotation$Animal_ID <- sub("-", "_", annotation$Animal_ID)
#annotation$Animal_ID <- sub("\\(", "_", annotation$Animal_ID)
#annotation$Animal_ID <- sub("\\)", "", annotation$Animal_ID)
#
## Create a mapping for the custom counts
#mapping.df.custom <- data.frame(sample_ID = rownames(annotation), 
#                         AOI_ID = paste0(annotation$segmentID, 
#                                              "|", 
#                                              annotation$Animal_ID))
#
## Gather the counts for the custom ID
#q3.counts.custom <- q3.normalization.output$object@assayData$q_norm

# Rename the columns in the counts df to the custom ID
#colnames(q3.counts.custom)[match(mapping.df.custom$sample_ID, colnames(q3.counts.custom))] <- mapping.df.custom$AOI_ID

# Create a mapping for the segment ID counts
mapping.df.segmentID <- data.frame(sample_ID = rownames(annotation), 
                         segmentID = annotation$segmentID)

# Gather the counts for the segment ID
q3.counts.segmentID <- q3.normalization.output$object@assayData$q_norm

# Rename the columns in the counts df to the custom ID
colnames(q3.counts.segmentID)[match(mapping.df.segmentID$sample_ID, colnames(q3.counts.segmentID))] <- mapping.df.segmentID$segmentID

# Create a renamed quantile counts df
quantile.norm.counts.renamed <- quantile.normalization.counts
colnames(quantile.norm.counts.renamed)[match(mapping.df.segmentID$sample_ID, colnames(quantile.norm.counts.renamed))] <- mapping.df.segmentID$segmentID


export <- FALSE

if(export){
  
  write.csv(q3.counts.segmentID, 
            file = paste0(params$results.folder, "q3_normalized_counts_all_regions.csv"))
  
  write.csv(quantile.normalization.counts, 
            file = paste0(params$results.folder, "quantile_normalized_counts_all_regions.csv"))
  
}

    
```

#### RLE Plots

```{r RLE Plots, fig.width=12, fig.height=8}
#| label: fig-NormEffects
#| fig-cap: "Normalization Effects on Counts"
#| warning: false
#| message: false

raw.counts <- q3.normalization.output$object@assayData$exprs
q3.counts <- q3.normalization.output$object@assayData$q_norm
annotation.df <- pData(q3.normalization.output$object)

raw.rle.plot <- make_rle_plot(counts = raw.counts, 
                              annotation = annotation.df, 
                              annotation.facet = "region")

q3.rle.plot <- make_rle_plot(counts = q3.counts, 
                              annotation = annotation.df, 
                              annotation.facet = "region")

quantile.rle.plot <- make_rle_plot(counts = quantile.normalization.counts, 
                              annotation = annotation.df, 
                              annotation.facet = "region")

print(q3.rle.plot)
print(quantile.rle.plot)

```

**Example AOIs**

@fig-NormEffects shows the raw and normalized read count boxplots for an example 30 AOIs

```{r Normalization Effects on Counts, fig.width=12, fig.height=8}
#| label: fig-NormEffects
#| fig-cap: "Normalization Effects on Counts"
#| warning: false
#| message: false

# The raw counts boxplot
example.counts <- q3.normalization.output$object@assayData$exprs[,1:30]
example.counts.df <- as.data.frame(example.counts)
example.counts.melt.raw <- melt(example.counts.df)
ggboxplot.raw <- ggplot(example.counts.melt.raw, aes(variable, value)) +
  stat_boxplot(geom = "errorbar") +
  geom_boxplot(fill="grey") +
  scale_y_log10() +
  xlab("Example AOIs") + 
  ylab("Counts, Raw") +
  ggtitle("Raw Counts Example AOIs") +
  scale_x_discrete(labels=c(1:30))

# The Q3 normalized counts boxplot
example.counts <- q3.normalization.output$object@assayData$q_norm[,1:30]
example.counts.df <- as.data.frame(example.counts)
example.counts.melt.q3 <- melt(example.counts.df)
ggboxplot.q3norm <- ggplot(example.counts.melt.q3, aes(variable, value)) +
  stat_boxplot(geom = "errorbar") +
  geom_boxplot(fill="cadetblue2") +
  scale_y_log10() +
  xlab("Example AOIs") + 
  ylab("Counts, Q3 Normalized") +
  ggtitle("Q3 Counts Example AOIs") +
  scale_x_discrete(labels=c(1:30))

# The Negative normalized counts boxplot
example.counts <- neg.normalization.output$object@assayData$neg_norm[,1:30]
example.counts.df <- as.data.frame(example.counts)
example.counts.melt.neg <- melt(example.counts.df)
ggboxplot.negnorm <- ggplot(example.counts.melt.neg, aes(variable, value)) +
  stat_boxplot(geom = "errorbar") +
  geom_boxplot(fill="indianred") +
  scale_y_log10() +
  xlab("Example AOIs") + 
  ylab("Counts, Neg. Normalized") +
  ggtitle("Neg Counts Example AOIs") +
  scale_x_discrete(labels=c(1:30))

# The Quantile normalized counts boxplot
example.counts <- quantile.normalization.counts[,1:30]
example.counts.df <- as.data.frame(example.counts)
example.counts.melt.quant <- melt(example.counts.df)
ggboxplot.quantnorm <- ggplot(example.counts.melt.quant, aes(variable, value)) +
  stat_boxplot(geom = "errorbar") +
  geom_boxplot(fill="magenta3") +
  scale_y_log10() +
  xlab("Example AOIs") + 
  ylab("Counts, Quantile Normalized") +
  ggtitle("Quantile Counts Example AOIs") +
  scale_x_discrete(labels=c(1:30))

print(ggboxplot.raw)
print(ggboxplot.q3norm)
print(ggboxplot.negnorm)
print(ggboxplot.quantnorm)
```

#### Signal to Noise

```{r}

signal.to.noise.boxplot <- function(signal.to.noise.df, 
                                    annotation, 
                                    group.field, 
                                    facet.field = NULL){
  
  signal.to.noise.cleaned <- as.data.frame(t(signal.to.noise.df))
  signal.to.noise.cleaned$sampleID <- gsub("\\.dcc", "", rownames(signal.to.noise.cleaned))
  
  #gene.columns <- setdiff(colnames(signal.to.noise.cleaned), select.columns)
  gene.df <- signal.to.noise.cleaned %>% 
    select(-sampleID)
  
  gene.columns <- colnames(gene.df)
  
  
  
  # Create a column for the median value
  signal.to.noise.cleaned <- signal.to.noise.cleaned %>% 
  rowwise() %>%
  mutate(s2n_median = median(c_across(all_of(gene.columns)))) %>%
  ungroup()
  
  # Gather columns from the annotation
  if(is.null(facet.field)){
    select.columns <- c("sampleID", group.field)
  } else {
    select.columns <- c("sampleID", group.field, facet.field)
  }
  
  annotation.subset <- annotation %>% 
    select(all_of(select.columns))
  
  s2n.annotation <- merge(signal.to.noise.cleaned, annotation, by = "sampleID")
  
  s2n.annotation.median <- s2n.annotation %>% 
    select(all_of(c(select.columns, "s2n_median")))
  
  # convert all columns to character strings
  s2n.annotation.median[] <- lapply(s2n.annotation.median, as.character)
  
  s2n.annotation.melt <- pivot_longer(s2n.annotation.median, 
                                      cols = "s2n_median", 
                                      names_to = "median", 
                                      values_to = "signal_to_noise")
  
  median.select.columns <- c("class", "region", "s2n_median")
  
  s2n.annotation.median.subset <- s2n.annotation.median %>% 
    select(all_of(median.select.columns))
  
  s2n.annotation.median.subset$s2n_median <- as.numeric(s2n.annotation.median.subset$s2n_median)
  
  s2n.median.boxplot <- ggplot(s2n.annotation.median.subset, aes(x = region, y = s2n_median, color = region)) +
  geom_boxplot() +
  facet_wrap(~ `class`) +
  labs(x = "Region", y = "Median Signal-to-Noise", color = "Region") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
}


# Gather the QC data, this will be identical for all normalizations
pheno.data <- as.data.frame(q3.normalization.output$object@phenoData@data)
pheno.data$sampleID <- rownames(pheno.data)

# Find the LOQ column
loq.field <- names(pheno.data)[grep("loq", colnames(pheno.data))]

# Define and create the LOQ data frame
loq.fields <- c("sampleID", loq.field)
LOQ.data <-  pheno.data %>% select(all_of(loq.fields))

# Gather the loq values (nested df) for each sample into a vector
LOQ.values <- c()
for(i in 1:nrow(LOQ.data)){
  LOQ.values <- c(LOQ.values, unlist(lapply(LOQ.data$loq, function(x) x[[i]])))
}

# Add LOQ values back to the LOQ df
LOQ.data$LOQ <- LOQ.values

# A function for calculating signal to noise for each gene in each AOI
signal_to_noise <- function(LOQ.data, 
                            normalized.counts){
  # Convert all counts to signal to noise ratio in a new df
  signal.to.noise.df <- as.data.frame(normalized.counts) %>% 
      mutate(across(everything(), ~ . / LOQ.data[rownames(LOQ.data) == cur_column(), "LOQ"]))
  return(signal.to.noise.df)
}

# Calculate signal to noise for all normalization types
q3.signal.to.noise <- signal_to_noise(LOQ.data = LOQ.data, 
                                      normalized.counts = q3.normalization.output$object@assayData$q_norm)

neg.signal.to.noise <- signal_to_noise(LOQ.data = LOQ.data, 
                                      normalized.counts = neg.normalization.output$object@assayData$neg_norm)

quant.signal.to.noise <- signal_to_noise(LOQ.data = LOQ.data, 
                                      normalized.counts = quantile.normalization.counts)


# Create the cleaned annotation

# Load the annotation (same for both normalization types)
annotation <- pData(q3.normalization.output$object)

# Remove NTCs
cleaned.annotation.df <- as.data.frame(annotation[annotation$'slide_name' != "No Template Control", ])

# Create a column for the nuclei bin
cleaned.annotation.df$nuclei_bin <- cut(cleaned.annotation.df$nuclei,
                     breaks = c(0, 10, 20, 50, Inf),
                     labels = c("1-10", "11-20", "21-50", ">51"),
                     right = TRUE) 

# Remove .dcc from Sample ID row names
cleaned.annotation.df <- cleaned.annotation.df %>% `rownames<-`(sub("\\.dcc", "", rownames(.)))

cleaned.annotation.df$sampleID <- rownames(cleaned.annotation.df)

#s2n.boxplot.q3 <- signal.to.noise.boxplot(signal.to.noise.df = q3.signal.to.noise, 
#                                    annotation = cleaned.annotation.df, 
#                                    group.field = "region", 
#                                    facet.field = "class")
#
#s2n.boxplot.neg <- signal.to.noise.boxplot(signal.to.noise.df = neg.signal.to.noise, 
#                                    annotation = cleaned.annotation.df, 
#                                    group.field = "region", 
#                                    facet.field = "class")
#
#s2n.boxplot.quant <- signal.to.noise.boxplot(signal.to.noise.df = quant.signal.to.noise, 
#                                    annotation = cleaned.annotation.df, 
#                                    group.field = "region", 
#                                    facet.field = "class")

```

#### Principal Component Analysis (PCA)

```{r PCA, warning=FALSE, message=FALSE}

# See reference vignette: https://bioconductor.org/packages/release/bioc/vignettes/PCAtools/inst/doc/PCAtools.html#introduction

# Load the Geomx objects
object.q3 <- q3.normalization.output$object
object.neg <- neg.normalization.output$object

# Gather the the normalized counts
q3.norm.counts.df <- as.data.frame(object.q3@assayData$q_norm)
neg.norm.counts.df <- as.data.frame(object.neg@assayData$neg_norm)
quant.norm.counts.df <- as.data.frame(quantile.normalization.counts)


# Convert counts to log2
q3.log.counts.df <- q3.norm.counts.df %>% 
  mutate_all(~ log2(.)) %>% 
  rename_all(~ gsub("\\.dcc", "", .))
neg.log.counts.df <- neg.norm.counts.df %>% 
  mutate_all(~ log2(.)) %>% 
  rename_all(~ gsub("\\.dcc", "", .))
quant.log.counts.df <- quant.norm.counts.df %>% 
  mutate_all(~ log2(.)) %>% 
  rename_all(~ gsub("\\.dcc", "", .))

# Remove the negative controls from the log counts
control.probes <- c("NegProbe-WTX")
q3.log.counts.df <- q3.log.counts.df[!(rownames(q3.log.counts.df) %in% control.probes), ]
neg.log.counts.df <- neg.log.counts.df[!(rownames(neg.log.counts.df) %in% control.probes), ]
quant.log.counts.df <- quant.log.counts.df[!(rownames(quant.log.counts.df) %in% control.probes), ]

# Load the annotation (same for both normalization types)
annotation <- pData(object.q3)

# Remove NTCs
cleaned.annotation.df <- as.data.frame(annotation[annotation$'slide_name' != "No Template Control", ])

# Create a column for the nuclei bin
cleaned.annotation.df$nuclei_bin <- cut(cleaned.annotation.df$nuclei,
                     breaks = c(0, 10, 20, 50, Inf),
                     labels = c("1-10", "11-20", "21-50", ">51"),
                     right = TRUE) 

# Order of rownames of annotation need to match columns of count data
cleaned.annotation.df <- cleaned.annotation.df[order(rownames(cleaned.annotation.df)), ]

q3.log.counts.df <- q3.log.counts.df[order(colnames(q3.log.counts.df))]
neg.log.counts.df <- neg.log.counts.df[order(colnames(neg.log.counts.df))]
quant.log.counts.df <- quant.log.counts.df[order(colnames(quant.log.counts.df))]

# Remove .dcc from Sample ID row names
cleaned.annotation.df <- cleaned.annotation.df %>% `rownames<-`(sub("\\.dcc", "", rownames(.)))

# Generate a PCA table for all samples for both normalization types
q3.pca.table <- pca(q3.log.counts.df, 
                 metadata = cleaned.annotation.df, 
                 removeVar = 0.1)
neg.pca.table <- pca(neg.log.counts.df, 
                 metadata = cleaned.annotation.df, 
                 removeVar = 0.1)
quant.pca.table <- pca(quant.log.counts.df, 
                 metadata = cleaned.annotation.df, 
                 removeVar = 0.1)

```

#### PCA by Animal ID

```{r PCA for Q3 segment, fig.width=12, fig.height=8}
#| label: fig-PCAsegmentQ3
#| fig-cap: "PCA colored by Animal_ID for Q3 Normalization"
#| warning: false

q3.pca.plot.segment <- biplot(q3.pca.table, 
                         colby = "Animal_ID", 
                         legendPosition = "right", 
                         legendLabSize = 6, 
                         legendIconSize = 3, 
                         lab = NULL,
                         title = "Q3 Normalization", 
                         subtitle = "NTCs removed")

print(q3.pca.plot.segment)

```

```{r PCA for Negative segment, fig.width=12, fig.height=8}
#| label: fig-PCAsegmentNeg
#| fig-cap: "PCA colored by Animal_ID for Negative Normalization"
#| warning: false

neg.pca.plot.segment <- biplot(neg.pca.table, 
                         colby = "Animal_ID", 
                         legendPosition = "right", 
                         legendLabSize = 6, 
                         legendIconSize = 3, 
                         lab = NULL,
                         title = "Negative Normalization", 
                         subtitle = "NTCs removed")

print(neg.pca.plot.segment)

```

```{r PCA for Quant segment, fig.width=12, fig.height=8}
#| label: fig-PCAsegmentQuant
#| fig-cap: "PCA colored by Segment for Quantile Normalization"
#| warning: false

quant.pca.plot.segment <- biplot(quant.pca.table, 
                         colby = "Animal_ID", 
                         legendPosition = "right", 
                         legendLabSize = 6, 
                         legendIconSize = 3, 
                         lab = NULL,
                         title = "Quantile Normalization", 
                         subtitle = "NTCs removed")

print(quant.pca.plot.segment)


```

#### PCA by Region

```{r PCA for Q3 region, fig.width=12, fig.height=8}
#| label: fig-PCAregionQ3
#| fig-cap: "PCA colored by Region for Q3 Normalization"
#| warning: false

q3.pca.plot.region <- biplot(q3.pca.table, 
                         colby = "region", 
                         legendPosition = "right", 
                         legendLabSize = 10, 
                         legendIconSize = 5, 
                         lab = NULL,
                         title = "Q3 Normalization", 
                         subtitle = "NTCs removed")


print(q3.pca.plot.region)

```

```{r PCA for Neg region, fig.width=12, fig.height=8}
#| label: fig-PCAregionNeg
#| fig-cap: "PCA colored by Region for Negative Normalization"
#| warning: false

neg.pca.plot.region <- biplot(neg.pca.table, 
                         colby = "region", 
                         legendPosition = "right", 
                         legendLabSize = 10, 
                         legendIconSize = 5, 
                         lab = NULL,
                         title = "Negative Normalization", 
                         subtitle = "NTCs removed")

print(neg.pca.plot.region)

```

```{r PCA for Quant region, fig.width=12, fig.height=8}
#| label: fig-PCAregionQuant
#| fig-cap: "PCA colored by Region for Quantile Normalization"
#| warning: false

quant.pca.plot.region <- biplot(quant.pca.table, 
                         colby = "region", 
                         legendPosition = "right", 
                         legendLabSize = 10, 
                         legendIconSize = 5, 
                         lab = NULL,
                         title = "Quantile Normalization", 
                         subtitle = "NTCs removed")

print(quant.pca.plot.region)


```

#### PCA by Class

```{r PCA for Q3 class, fig.width=12, fig.height=8}
#| label: fig-PCAclassQ3
#| fig-cap: "PCA colored by Class for Q3 Normalization"
#| warning: false

q3.pca.plot.class <- biplot(q3.pca.table, 
                         colby = "class", 
                         legendPosition = "right", 
                         legendLabSize = 10, 
                         legendIconSize = 5, 
                         lab = NULL,
                         title = "Q3 Normalization", 
                         subtitle = "NTCs removed")

print(q3.pca.plot.class)

```

```{r PCA for Negative class, fig.width=12, fig.height=8}
#| label: fig-PCAclassNeg
#| fig-cap: "PCA colored by Class for Negative Normalization"
#| warning: false

neg.pca.plot.class <- biplot(neg.pca.table, 
                         colby = "class", 
                         legendPosition = "right", 
                         legendLabSize = 10, 
                         legendIconSize = 5, 
                         lab = NULL,
                         title = "Negative Normalization", 
                         subtitle = "NTCs removed")

print(neg.pca.plot.class)

```

```{r PCA for Quantile class, fig.width=12, fig.height=8}
#| label: fig-PCAclassQuant
#| fig-cap: "PCA colored by Class for Quantile Normalization"
#| warning: false

quant.pca.plot.class <- biplot(quant.pca.table, 
                         colby = "class", 
                         legendPosition = "right", 
                         legendLabSize = 10, 
                         legendIconSize = 5, 
                         lab = NULL,
                         title = "Quantile Normalization", 
                         subtitle = "NTCs removed")

print(quant.pca.plot.class)


```

#### PCA by Slide

```{r PCA for Q3 slide, fig.width=12, fig.height=8}
#| label: fig-PCAslideQ3
#| fig-cap: "PCA colored by Slide for Q3 Normalization"
#| warning: false


q3.pca.plot.slide <- biplot(q3.pca.table, 
                         colby = "slide_name", 
                         legendPosition = "right", 
                         legendLabSize = 10, 
                         legendIconSize = 5, 
                         lab = NULL,
                         title = "Q3 Normalization", 
                         subtitle = "NTCs removed")

print(q3.pca.plot.slide)

```

```{r PCA for Neg slide, fig.width=12, fig.height=8}
#| label: fig-PCAslideNeg
#| fig-cap: "PCA colored by Slide for Negative Normalization"
#| warning: false

neg.pca.plot.slide <- biplot(neg.pca.table, 
                         colby = "slide_name", 
                         legendPosition = "right", 
                         legendLabSize = 10, 
                         legendIconSize = 5, 
                         lab = NULL,
                         title = "Negative Normalization", 
                         subtitle = "NTCs removed")

print(neg.pca.plot.slide)

```

```{r PCA for Quant slide, fig.width=12, fig.height=8}
#| label: fig-PCAslideQuant
#| fig-cap: "PCA colored by Slide for Quantile Normalization"
#| warning: false

quant.pca.plot.slide <- biplot(quant.pca.table, 
                         colby = "slide_name", 
                         legendPosition = "right", 
                         legendLabSize = 10, 
                         legendIconSize = 5, 
                         lab = NULL,
                         title = "Quantile Normalization", 
                         subtitle = "NTCs removed")

print(quant.pca.plot.slide)


```

#### PCA by Nuclei Count

```{r PCA for Q3 nuclei, fig.width=12, fig.height=8}
#| label: fig-PCAnucleiQ3
#| fig-cap: "PCA colored by Nuclei Count for Q3 Normalization"
#| warning: false


q3.pca.plot.nuclei <- biplot(q3.pca.table, 
                         colby = "nuclei_bin", 
                         legendPosition = "right", 
                         legendLabSize = 10, 
                         legendIconSize = 5, 
                         lab = NULL,
                         title = "Q3 Normalization", 
                         subtitle = "NTCs removed")

print(q3.pca.plot.nuclei)


```

```{r PCA for Negative nuclei, fig.width=12, fig.height=8}
#| label: fig-PCAnucleiNeg
#| fig-cap: "PCA colored by Nuclei Count for Negative Normalization"
#| warning: false

neg.pca.plot.nuclei <- biplot(neg.pca.table, 
                         colby = "nuclei_bin", 
                         legendPosition = "right", 
                         legendLabSize = 10, 
                         legendIconSize = 5, 
                         lab = NULL,
                         title = "Negative Normalization", 
                         subtitle = "NTCs removed")

print(neg.pca.plot.nuclei)
```

```{r PCA for Quant nuclei, fig.width=12, fig.height=8}
#| label: fig-PCAnucleiQuant
#| fig-cap: "PCA colored by Nuclei Count for Quantile Normalization"
#| warning: false

quant.pca.plot.nuclei <- biplot(quant.pca.table, 
                         colby = "nuclei_bin", 
                         legendPosition = "right", 
                         legendLabSize = 10, 
                         legendIconSize = 5, 
                         lab = NULL,
                         title = "Quantile Normalization", 
                         subtitle = "NTCs removed")

print(quant.pca.plot.nuclei)

```

### MA Plots

```{r}
# Set up pre and post normalization counts and convert to log

pre.norm.counts <-
  log(as.data.frame(q3.normalization.output$object@assayData$exprs), base = 2)

post.q3norm.counts <- log(as.data.frame(q3.normalization.output$object@assayData$q_norm), base = 2)

post.negnorm.counts <- log(as.data.frame(neg.normalization.output$object@assayData$neg_norm), base = 2)

post.quantnorm.counts <- log(as.data.frame(quantile.normalization.counts), 
                             base = 2)

# Setup annotation groups for the ratio "M" (log A - log B)
#tumor.types <- c("Biopsy")
class.types <- c("T4", "C")
region.types <- c("tumor", "vessel")
#source.types <- c("Skin")
#segment.types <- c("full_ROI")

# Define the name of the contrast
contrast.name <- paste0(class.types[[1]], 
                        "_", 
                        class.types[[2]])

# Set up the annotations and raw counts for the MA plots
contrast.field.class <- "class"
condition.label.class <- "T4"
reference.label.class <- "C"
contrast.field.region <- "region"
condition.label.region <- "tumor"
reference.label.region <- "vessels"
raw.log.counts <- pre.norm.counts
annotation.MA <- annotation


```

#### Q3 Normalization

```{r MA Plot Q3 Class, message=FALSE, warning=FALSE, fig.width=12, fig.height=8}
# MA plots for two annotation groups to evaluate negative normalization
log.counts <- post.q3norm.counts

MA.plots.q3.class <- make_MA(contrast.field = contrast.field.class, 
                       condition.label = condition.label.class, 
                       reference.label = reference.label.class, 
                       log.counts = log.counts, 
                       raw.log.counts = raw.log.counts, 
                       annotation = annotation.MA)

  
grid.draw(MA.plots.q3.class)

```

```{r MA Plot Q3 Region, message=FALSE, warning=FALSE, fig.width=12, fig.height=8}
# MA plots for two annotation groups to evaluate negative normalization

MA.plots.q3.region <- make_MA(contrast.field = contrast.field.region, 
                       condition.label = condition.label.region, 
                       reference.label = reference.label.region, 
                       log.counts = log.counts, 
                       raw.log.counts = raw.log.counts, 
                       annotation = annotation.MA)

grid.draw(MA.plots.q3.region)
```

#### Negative Normalization

```{r MA Plot Neg Class, message=FALSE, warning=FALSE, fig.width=12, fig.height=8}

# MA plots for two annotation groups to evaluate negative normalization
log.counts <- post.negnorm.counts

MA.plots.neg.class <- make_MA(contrast.field = contrast.field.class, 
                       condition.label = condition.label.class, 
                       reference.label = reference.label.class, 
                       log.counts = log.counts, 
                       raw.log.counts = raw.log.counts, 
                       annotation = annotation.MA)

  
grid.draw(MA.plots.neg.class)

```

```{r MA Plot Neg Region, message=FALSE, warning=FALSE, fig.width=12, fig.height=8}

# MA plots for two annotation groups to evaluate negative normalization

MA.plots.neg.region <- make_MA(contrast.field = contrast.field.region, 
                       condition.label = condition.label.region, 
                       reference.label = reference.label.region, 
                       log.counts = log.counts, 
                       raw.log.counts = raw.log.counts, 
                       annotation = annotation.MA)

grid.draw(MA.plots.neg.region)
```

#### Quantile Normalization

```{r MA Plot Quant class, message=FALSE, warning=FALSE, fig.width=12, fig.height=8}
# MA plots for two annotation groups to evaluate quantile normalization
log.counts <- post.quantnorm.counts

MA.plots.quant.class <- make_MA(contrast.field = contrast.field.class, 
                       condition.label = condition.label.class, 
                       reference.label = reference.label.class, 
                       log.counts = log.counts, 
                       raw.log.counts = raw.log.counts, 
                       annotation = annotation.MA)
  
grid.draw(MA.plots.quant.class)

```

```{r MA Plot Quant region, message=FALSE, warning=FALSE, fig.width=12, fig.height=8}
# MA plots for two annotation groups to evaluate quantile normalization
MA.plots.quant.region <- make_MA(contrast.field = contrast.field.region, 
                       condition.label = condition.label.region, 
                       reference.label = reference.label.region, 
                       log.counts = log.counts, 
                       raw.log.counts = raw.log.counts, 
                       annotation = annotation.MA)

grid.draw(MA.plots.quant.region)
```

### Genes of Interest Boxplot

```{r GOI Boxplot}

goi.boxplot <- gene_counts_violin_boxplot(counts = q3.counts, 
                                          annotation.df = annotation, 
                                          gene.list = c("Cdh5", "Pecam1"), 
                                          annotation.field = "region", 
                                          display.summary.stat = FALSE, 
                                          compare.groups = FALSE)

print(goi.boxplot)


```

### Check Overall Cdh5 Counts

```{r Check Cdh5 Counts}
#| warning: false
#| message: false

# Gather the Cdh5 level of tumor AOIs

# Subset for Tumor AOIs

tumor.aoi.annotation <- annotation %>% 
  filter(`Custom Segment Name` == "tumor")

tumor.aoi.IDs <- tumor.aoi.annotation$segmentID

quant.counts.df <- as.data.frame(quantile.norm.counts.renamed)

tumor.counts <- quant.counts.df %>% 
  select(all_of(tumor.aoi.IDs))

# Gather the cdh5 level for tumor to compare to vessels
cdh5.avg.tumor <- mean(as.numeric(tumor.counts["Cdh5",]))


# Sebet for Vessel AOIs
vessel.aoi.annotation <- annotation %>% 
  filter(`Custom Segment Name` == "vessels")

vessel.aoi.IDs <- vessel.aoi.annotation$segmentID

quant.counts.df <- as.data.frame(quantile.norm.counts.renamed)

vessel.counts <- quant.counts.df %>% 
  select(all_of(vessel.aoi.IDs))

vessel.cdh5.counts <- vessel.counts["Cdh5",]

vessel.cdh5.compare <- as.data.frame(t(vessel.cdh5.counts))
vessel.cdh5.compare$above_tumor_mean <- vessel.cdh5.compare$Cdh5 > cdh5.avg.tumor

vessel.cdh5.low <- vessel.cdh5.compare %>% 
  filter(above_tumor_mean == FALSE)


```
